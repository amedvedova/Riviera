;+; NAME:;   AML_SON_read_r2tc.pro;; PURPOSE:;   sonic-daten einlesen. liest binärdaten des gillr2-transitcount-formates der;   labview-erfassung ein und wandelt die transit counts in unkalibrierte uvw;   daten um. output ist ein array der form:;;   u v w t (ai1 ai2 ...);   u v w t (ai1 ai2 ...);   . . . .  .   .;   . . . .  .   .;   . . . .  .   .;;   float-array(4+anz_ai,r), r ist die anzahl eingelesener;   records, ai anzahl analog inputs, die temperatur wird in celsius ausgegeben.;   für gill r2 daten im uvw format existiert das program "AML_SON_r2uvw.pro".;; CALLING SEQUENCE:;   result=AML_SON_read_r2tc(filepath, anz_ai=anz_ai, pathlength=pathlength);; INPUTS:;   filepath    : vollständiger pfad des rohdatenfiles mit transit counts;   anz_ai      : anzahl analog-inputs, die aufgeschaltet sind.;   pathlength  : array[3]. individuelle pfadlängen in m;; OUTPUT:;   array[4+anz_ai,r];;   u,v und w sind ein linkshändiges system.;   u+ zeigt nach 150° (~SSE) bez. dem nordpfeil auf dem sonic;   v+ zeigt nach 240° (~WSW) bez. dem nordpfeil auf dem sonic;   w+ zeigt nach oben;; EXAMPLE:;   data=AML_SON_read_r2tc('\\gibm-ntserver3\map\data\ag\rohdaten\fast\234\AG_N2_1999_234_170000.raw');   mit 1 analog_input:;   data=AML_SON_read_r2tc('\\gibm-ntserver3\map\data\ro\rohdaten\fast\259\RO_N2_1999_259_150000.raw', anz_ai=1);   mit individuellen pfadlängen:;   data=AML_SON_read_r2tc('\\gibm-ntserver3\map\data\ag\rohdaten\fast\239\AG_N2_1999_239_173000.raw', pathlength=[0.1443119,0.1463585,0.1460751]);   anschliessend gill-kalibrierung anwenden:;   data=AML_SON_gillcal(data,208);; REVISION HISTORY:;   28.08.99 AC  (MAP);   18.01.99 AC  wenn ID-byte-kontrolle nicht bestanden -> "-1" als result, da daten unbrauchbar.;   27.01.99 AC  wenn datafile leer -> "-1" als result.;   17.02.99 AC  r2 billig rausgenommen und umbenannt zu "gillr2_in_tc". jetzt werden tc rausgegeben.;                altes program aus kompatibilitästgründen weiterbehalten. keywords eingeführt.;   23.03.00 EvG implementiert, dass byte shift abfangen wird;   24.04.00 EvG fehlende analog inputs werden als byte shift interpretiert. neu als -1 ausgegeben;   12.11.01 AC  in AML implementiert und gleich die pure-kalibrierung hinten angehängt. geckecht mit;                den map-programmen. matrix- und gill-kalibrierung müssen hinten angehängt werden.;                fehler analog input korrigiert. statt 1 jetzt 256.;-;GILL R2 TRANSIT COUNT FORMAT (1 zeichen entspricht 1 byte, ausgenommen []):;1122334455667788[aa]99;;1 = start of record HEX "8181" = -32383;2 = record number (Counter);3 = transit count t-b axis 1 msb/lsb;4 = transit count b-t axis 1 msb/lsb;5 = transit count t-b axis 2 msb/lsb;6 = transit Count b-t axis 2 msb/lsb;7 = transit Count t-b axis 3 msb/lsb;8 = transit Count b-t axis 3 msb/lsb;[a] = analog inputs msb/lsb;9 = end of record HEX "8282" = -32126function AML_SON_read_r2tc, filepfad, anz_ai=anz_ai, pathlength=pathlength    TFAK = 29491200D*0.5        ; Quarzfrequenz halbe    if not keyword_set(pathlength) then pathlength=dblarr(3)+0.149    tpfak=pathlength*tfak    openr, lun, filepfad, /get_lun    if not keyword_set(anz_ai) then anz_ai=0    r2 = {start_id: 0, counter: 0, tc: bytarr(12+anz_ai*2), end_id: 0}    fileinfo=fstat(lun)    if not keyword_set(n_recs) then begin  ; anzahl records selber berechnen (wenn '0' gesetzt)        n_recs=fileinfo.size/(18+2*anz_ai)    endifif fileinfo.size gt 200L then begin ;mindestens 2 records vorhanden in file    rawdata = replicate(r2,n_recs)    readu, lun, rawdata    close, lun    free_lun, lun;data check -------------    fehler=where(rawdata.start_id ne -32383, cnt)    if cnt ne 0 then begin    message,'Error in transit count data '+fileinfo.name, /informational    test=bytarr(fileinfo.size)    ;das ganze in eimem schlonz einlesen...    openr, lun, filepfad, /get_lun    readu,lun,test    close, lun    free_lun, lun    pointer=fltarr(fileinfo.size/(18+2*anz_ai))    n_recs=-1.d    for i=0d,fileinfo.size-3 do begin        if test(i) eq 129 and test(i+1) eq 129  then begin            if (i/18.+2*anz_ai) lt n_elements(pointer) then pointer(i/(18.+2*anz_ai))=i else pointer=0            n_recs=n_recs+1        endif    endfor    if n_elements(pointer) gt n_recs and n_recs gt 0 then begin    message,'Reading again '+fileinfo.name+' ID byte shift detected', /informational    rawdata = replicate (r2,n_recs)    ;zuweisen das ganze    ;------------------    for i = 0d,n_recs-12 do begin        rawdata(i:i+1).start_id         = test(pointer(i):pointer(i)+1)        rawdata(i:i+1).counter          = test(pointer(i)+2:pointer(i)+3)        rawdata(i:i+11).tc              = test(pointer(i)+4:pointer(i)+15)        if anz_ai gt 0 then begin            rawdata(i:i+1).ai = test(pointer(i)+16:pointer(i)+17)            rawdata(i:i+1).end_id = test(pointer(i)+18:pointer(i)+19)        endif else rawdata(i:i+1).end_id = test(pointer(i)+16:pointer(i)+17)    endfor    endif else begin        message,'Error: array could not be repaired by byte shift', /informational        rettc=-1        return,rettc    endelseendif; ende data check / byte shift    ;transit counts    tc=intarr(6+anz_ai,n_recs)    ;muss int sein für negative werte! entgegen dem gill-manual können    ;auch negative werte gemessen werden!    for i=0, 6+anz_ai-1 do tc[i,*]=fix(rawdata.tc[i*2]*256)+fix(rawdata.tc[i*2+1])  endif else begin        print, 'error in <gillr2_in_array.pro>: no data in data file '+filepfad        rettc=-1        return,rettc  endelse ;mindestens 2 records vorhanden in file  uvw=fltarr(4+anz_ai,n_recs)  ; achsen- und schallgeschwindigkeiten  a1  = reform(TPFAK(0)/tc(0,*)-TPFAK(0)/tc(1,*))  a2  = reform(TPFAK(1)/tc(2,*)-TPFAK(1)/tc(3,*))  a3  = reform(TPFAK(2)/tc(4,*)-TPFAK(2)/tc(5,*))    ; umrechnen ins uvw-SONIC Koordinatensystem  uvw[0,*] = reform((2*a1 - a2 - a3)/2.1213D)  uvw[1,*] = reform((       a2 - a3)/1.2247D)  uvw[2,*] = reform(( -a1 - a2 - a3)/2.1213D)  c1  = reform(TPFAK(0)/tc(0,*)+TPFAK(0)/tc(1,*))  c2  = reform(TPFAK(1)/tc(2,*)+TPFAK(1)/tc(3,*))  c3  = reform(TPFAK(2)/tc(4,*)+TPFAK(2)/tc(5,*))  for a=0, anz_ai-1 do begin    uvw[4+a,*] = tc[6+a,*] ;analog inputs shiften  endfor  ; Speicher der Transitcounts tc freigeben  tc = 0B  ; Temperaturen (ohne Feuchte-Korrektur)  ; Geschwindigkeitskomponente normal zum Pfad berechnen  vu = sqrt((uvw[0,*]^2 + uvw[1,*]^2 + uvw[2,*]^2 - a1^2)>0)  vv = sqrt((uvw[0,*]^2 + uvw[1,*]^2 + uvw[2,*]^2 - a2^2)>0)  vw = sqrt((uvw[0,*]^2 + uvw[1,*]^2 + uvw[2,*]^2 - a3^2)>0)  a1 = 0B &  a2 = 0B & a3 = 0B  anul = -273.15  ; ... und die Pfad-Temperaturen  if keyword_set(qq) then begin    t1 = reform((c1^2 + vu^2)/(402.7d*(1.0d + 0.51*qq/1200d)))+anul    t2 = reform((c2^2 + vv^2)/(402.7d*(1.0d + 0.51*qq/1200d)))+anul    t3 = reform((c3^2 + vw^2)/(402.7d*(1.0d + 0.51*qq/1200d)))+anul  endif  t1v = reform((c1^2 + vu^2)/402.7d)+anul  t2v = reform((c2^2 + vv^2)/402.7d)+anul  t3v = reform((c3^2 + vw^2)/402.7d)+anul  uvw[3,*] = (t1v+t2v+t3v)/3D  return, uvwend